<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Project Playcare</title>

<style>
body { margin:0; overflow:hidden; background:black; font-family:Arial; }

#ui {
position:absolute;
bottom:20px;
left:20px;
color:white;
font-size:14px;
opacity:0.8;
}

#crosshair {
position:absolute;
top:50%;
left:50%;
width:6px;
height:6px;
background:white;
transform:translate(-50%,-50%);
z-index:10;
}
</style>
</head>
<body>

<div id="ui">
WASD Move | Shift Sprint | Space Jump | Click = GrabPack
</div>

<div id="crosshair"></div>

<audio id="bgm1" src="Bgm-1.mp3" loop autoplay></audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>

/* ================= BASIC SETUP ================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1e1f24);

const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,2000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

renderer.domElement.addEventListener("click",()=>{
renderer.domElement.requestPointerLock();
});

/* ================= LIGHT ================= */

scene.add(new THREE.AmbientLight(0xffffff,0.5));
const light = new THREE.PointLight(0xffffff,1,200);
light.position.set(0,10,0);
scene.add(light);

/* ================= TEXTURES ================= */

const loader = new THREE.TextureLoader();

const wallTex = loader.load("https://threejs.org/examples/textures/brick_diffuse.jpg");
wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
wallTex.repeat.set(4,2);

const floorTex = loader.load("https://threejs.org/examples/textures/hardwood2_diffuse.jpg");
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(20,20);

/* ================= FLOOR ================= */

const floor = new THREE.Mesh(
new THREE.PlaneGeometry(300,300),
new THREE.MeshStandardMaterial({map:floorTex})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ================= COLLISION ================= */

const colliders=[];
function addCollider(mesh){
mesh.userData.box=new THREE.Box3().setFromObject(mesh);
colliders.push(mesh);
}

function checkCollision(position){
const box=new THREE.Box3().setFromCenterAndSize(
position,
new THREE.Vector3(1,3,1)
);
for(let obj of colliders){
obj.userData.box.setFromObject(obj);
if(box.intersectsBox(obj.userData.box)) return true;
}
return false;
}

/* ================= WALL BUILDER ================= */

function wall(x,y,z,w,h,d){
const mesh=new THREE.Mesh(
new THREE.BoxGeometry(w,h,d),
new THREE.MeshStandardMaterial({map:wallTex})
);
mesh.position.set(x,y,z);
scene.add(mesh);
addCollider(mesh);
return mesh;
}

/* ================= ROOM ================= */

wall(0,5,10,20,10,1);
wall(-10,5,0,1,10,20);
wall(10,5,0,1,10,20);
wall(0,9,0,20,1,20);
wall(0,5,-10,20,10,1);

/* ================= GRABBABLE OBJECT ================= */

const box = new THREE.Mesh(
new THREE.BoxGeometry(2,2,2),
new THREE.MeshStandardMaterial({color:0x00aaff})
);
box.position.set(0,1,-5);
scene.add(box);

let grabbableObjects=[box];

/* ================= PLAYER ================= */

const player=new THREE.Object3D();
player.position.set(0,2,5);
scene.add(player);
player.add(camera);

let yaw=0;
let pitch=0;

document.addEventListener("mousemove",(e)=>{
if(document.pointerLockElement===renderer.domElement){
yaw-=e.movementX*0.002;
pitch-=e.movementY*0.002;
pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
player.rotation.y=yaw;
camera.rotation.x=pitch;
}
});

/* ================= MOVEMENT ================= */

let keys={};
let velocityY=0;
let gravity=30;
let canJump=false;
let moveSpeed=6;
let sprintSpeed=10;
let prevTime=performance.now();

document.addEventListener("keydown",e=>keys[e.code]=true);
document.addEventListener("keyup",e=>keys[e.code]=false);

function animate(){
requestAnimationFrame(animate);

let time=performance.now();
let delta=(time-prevTime)/1000;
prevTime=time;

let forward=new THREE.Vector3();
camera.getWorldDirection(forward);
forward.y=0;
forward.normalize();

let right=new THREE.Vector3();
right.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();

let moveDir=new THREE.Vector3();
if(keys["KeyW"]) moveDir.add(forward);
if(keys["KeyS"]) moveDir.sub(forward);
if(keys["KeyA"]) moveDir.sub(right);
if(keys["KeyD"]) moveDir.add(right);
moveDir.normalize();

let speed=(keys["ShiftLeft"])?sprintSpeed:moveSpeed;

let newPos=player.position.clone();
newPos.addScaledVector(moveDir,speed*delta);
if(!checkCollision(newPos)){
player.position.x=newPos.x;
player.position.z=newPos.z;
}

velocityY-=gravity*delta;
if(keys["Space"] && canJump){
velocityY=12;
canJump=false;
}
player.position.y+=velocityY*delta;
if(player.position.y<=2){
player.position.y=2;
velocityY=0;
canJump=true;
}

/* ================= GRABPACK ================= */

renderer.render(scene,camera);
}
animate();

/* ================= GRAB LOGIC ================= */

const raycaster=new THREE.Raycaster();

document.addEventListener("mousedown",()=>{
raycaster.setFromCamera(new THREE.Vector2(0,0),camera);
const intersects=raycaster.intersectObjects(grabbableObjects);

if(intersects.length>0){
const obj=intersects[0].object;

/* Pull object toward player */
let pullInterval=setInterval(()=>{
let dir=new THREE.Vector3();
dir.subVectors(player.position,obj.position).normalize();
obj.position.addScaledVector(dir,0.3);

if(obj.position.distanceTo(player.position)<3){
clearInterval(pullInterval);
}
},16);
}
});

window.addEventListener("resize",()=>{
camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
